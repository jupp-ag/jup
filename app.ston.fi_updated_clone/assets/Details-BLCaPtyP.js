import{D as i,a as A,b as S}from"./constants-CYte1oil.js";import{d as n,a as ee}from"./ton-JVN5BOEN.js";import{C as w,J as a,t as d,e as f,B as te,c as se}from"./useBlockchainExplorer-Bfo5epRb.js";import{p as v,a as oe,R as C}from"./index-CxvHtgaJ.js";import{I as ne,k as re,j as T}from"./index-rYEy9Y7-.js";import{A as de,a as ae,c as ie,b as ue}from"./Accordion-4D3-142-.js";class _ extends w{async getBalance(t){if((await t.getState()).state.type!=="active")return BigInt(0);const{balance:s}=await this.getWalletData(t);return s}async getWalletData(t){const e=await t.get("get_wallet_data",[]);return{balance:e.stack.readBigNumber(),ownerAddress:e.stack.readAddress(),jettonMasterAddress:e.stack.readAddress(),jettonWalletCode:e.stack.readCell()}}}const k=class D extends w{constructor(t,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...D.gasConstants,...e}}async createRefundBody(t){return n.beginCell().storeUint(i.REFUND_ME,32).storeUint(t?.queryId??0,64).endCell()}async getRefundTxParams(t,e){const s=this.address,o=await this.createRefundBody({queryId:e?.queryId}),r=BigInt(e?.gasAmount??this.gasConstants.refund);return{to:s,value:r,body:o}}async sendRefund(t,e,s){const o=await this.getRefundTxParams(t,s);return e.send(o)}async createDirectAddLiquidityBody(t){return n.beginCell().storeUint(i.DIRECT_ADD_LIQUIDITY,32).storeUint(t?.queryId??0,64).storeCoins(BigInt(t.amount0)).storeCoins(BigInt(t.amount1)).storeCoins(BigInt(t.minimumLpToMint??1)).endCell()}async getDirectAddLiquidityTxParams(t,e){const s=this.address,o=await this.createDirectAddLiquidityBody({amount0:e.amount0,amount1:e.amount1,minimumLpToMint:e.minimumLpToMint,queryId:e.queryId}),r=BigInt(e.gasAmount??this.gasConstants.directAddLp);return{to:s,value:r,body:o}}async sendDirectAddLiquidity(t,e,s){const o=await this.getDirectAddLiquidityTxParams(t,s);return e.send(o)}async createResetGasBody(t){return n.beginCell().storeUint(i.RESET_GAS,32).storeUint(t?.queryId??0,64).endCell()}async getResetGasTxParams(t,e){const s=this.address,o=await this.createResetGasBody({queryId:e?.queryId}),r=BigInt(e?.gasAmount??this.gasConstants.resetGas);return{to:s,value:r,body:o}}async sendResetGas(t,e,s){const o=await this.getResetGasTxParams(t,s);return e.send(o)}async getLpAccountData(t){const e=await t.get("get_lp_account_data",[]);return{userAddress:e.stack.readAddress(),poolAddress:e.stack.readAddress(),amount0:e.stack.readBigNumber(),amount1:e.stack.readBigNumber()}}};k.version=A.v1;k.gasConstants={refund:n.toNano("0.3"),directAddLp:n.toNano("0.3"),resetGas:n.toNano("0.3")};let E=k;const I=class F extends a{constructor(t,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...F.gasConstants,...e}}async createCollectFeesBody(t){return n.beginCell().storeUint(i.COLLECT_FEES,32).storeUint(t?.queryId??0,64).endCell()}async getCollectFeeTxParams(t,e){const s=this.address,o=await this.createCollectFeesBody({queryId:e?.queryId}),r=BigInt(e?.gasAmount??this.gasConstants.collectFees);return{to:s,value:r,body:o}}async sendCollectFees(t,e,s){const o=await this.getCollectFeeTxParams(t,s);return e.send(o)}async createBurnBody(t){return n.beginCell().storeUint(i.BURN,32).storeUint(t?.queryId??0,64).storeCoins(BigInt(t.amount)).storeAddress(d(t.responseAddress)).endCell()}async getBurnTxParams(t,e){const[s,o]=await Promise.all([this.getWalletAddress(t,e.responseAddress),this.createBurnBody({amount:e.amount,responseAddress:e.responseAddress,queryId:e.queryId})]),r=BigInt(e.gasAmount??this.gasConstants.burn);return{to:s,value:r,body:o}}async sendBurn(t,e,s){const o=await this.getBurnTxParams(t,s);return e.send(o)}async getExpectedOutputs(t,e){const s=await t.get("get_expected_outputs",[{type:"int",value:BigInt(e.amount)},{type:"slice",cell:n.beginCell().storeAddress(d(e.jettonWallet)).endCell()}]);return{jettonToReceive:s.stack.readBigNumber(),protocolFeePaid:s.stack.readBigNumber(),refFeePaid:s.stack.readBigNumber()}}async getExpectedTokens(t,e){return(await t.get("get_expected_tokens",[{type:"int",value:BigInt(e.amount0)},{type:"int",value:BigInt(e.amount1)}])).stack.readBigNumber()}async getExpectedLiquidity(t,e){const s=await t.get("get_expected_liquidity",[{type:"int",value:BigInt(e.jettonAmount)}]);return{amount0:s.stack.readBigNumber(),amount1:s.stack.readBigNumber()}}async getLpAccountAddress(t,e){return(await t.get("get_lp_account_address",[{type:"slice",cell:n.beginCell().storeAddress(d(e.ownerAddress)).endCell()}])).stack.readAddress()}async getJettonWallet(t,e){const s=await this.getWalletAddress(t,e.ownerAddress);return _.create(s)}async getPoolData(t){const e=await t.get("get_pool_data",[]);return{reserve0:e.stack.readBigNumber(),reserve1:e.stack.readBigNumber(),token0WalletAddress:e.stack.readAddress(),token1WalletAddress:e.stack.readAddress(),lpFee:e.stack.readBigNumber(),protocolFee:e.stack.readBigNumber(),refFee:e.stack.readBigNumber(),protocolFeeAddress:e.stack.readAddress(),collectedToken0ProtocolFee:e.stack.readBigNumber(),collectedToken1ProtocolFee:e.stack.readBigNumber()}}async getLpAccount(t,e){const s=await this.getLpAccountAddress(t,e);return E.create(s)}};I.version=A.v1;I.gasConstants={collectFees:n.toNano("1.1"),burn:n.toNano("0.5")};let V=I;const h=class x extends w{constructor(t=x.address,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...x.gasConstants,...e}}async createSwapBody(t){const e=n.beginCell();return e.storeUint(i.SWAP,32),e.storeAddress(d(t.askJettonWalletAddress)),e.storeCoins(BigInt(t.minAskAmount)),e.storeAddress(d(t.userWalletAddress)),t.referralAddress?(e.storeUint(1,1),e.storeAddress(d(t.referralAddress))):e.storeUint(0,1),e.endCell()}async getSwapJettonToJettonTxParams(t,e){const[s,o]=await Promise.all([t.open(a.create(e.offerJettonAddress)).getWalletAddress(e.userWalletAddress),t.open(a.create(e.askJettonAddress)).getWalletAddress(this.address)]),r=await this.createSwapBody({userWalletAddress:e.userWalletAddress,minAskAmount:e.minAskAmount,askJettonWalletAddress:o,referralAddress:e.referralAddress}),u=BigInt(e.forwardGasAmount??this.gasConstants.swapJettonToJetton.forwardGasAmount),g=f({queryId:e.queryId??0,amount:e.offerAmount,destination:this.address,responseDestination:e.userWalletAddress,forwardTonAmount:u,forwardPayload:r}),y=BigInt(e.gasAmount??this.gasConstants.swapJettonToJetton.gasAmount);return{to:s,value:y,body:g}}async sendSwapJettonToJetton(t,e,s){const o=await this.getSwapJettonToJettonTxParams(t,s);return e.send(o)}async getSwapJettonToTonTxParams(t,e){return await this.getSwapJettonToJettonTxParams(t,{...e,askJettonAddress:e.proxyTon.address,gasAmount:e.gasAmount??this.gasConstants.swapJettonToTon.gasAmount,forwardGasAmount:e.forwardGasAmount??this.gasConstants.swapJettonToTon.forwardGasAmount})}async sendSwapJettonToTon(t,e,s){const o=await this.getSwapJettonToTonTxParams(t,s);return e.send(o)}async getSwapTonToJettonTxParams(t,e){const s=await t.open(a.create(e.askJettonAddress)).getWalletAddress(this.address),o=await this.createSwapBody({userWalletAddress:e.userWalletAddress,minAskAmount:e.minAskAmount,askJettonWalletAddress:s,referralAddress:e.referralAddress}),r=BigInt(e.forwardGasAmount??this.gasConstants.swapTonToJetton.forwardGasAmount);return await t.open(e.proxyTon).getTonTransferTxParams({queryId:e.queryId??0,tonAmount:e.offerAmount,destinationAddress:this.address,refundAddress:e.userWalletAddress,forwardPayload:o,forwardTonAmount:r})}async sendSwapTonToJetton(t,e,s){const o=await this.getSwapTonToJettonTxParams(t,s);return e.send(o)}async createProvideLiquidityBody(t){return n.beginCell().storeUint(i.PROVIDE_LP,32).storeAddress(d(t.routerWalletAddress)).storeCoins(BigInt(t.minLpOut)).endCell()}async getProvideLiquidityJettonTxParams(t,e){const[s,o]=await Promise.all([t.open(a.create(e.sendTokenAddress)).getWalletAddress(e.userWalletAddress),t.open(a.create(e.otherTokenAddress)).getWalletAddress(this.address)]),r=await this.createProvideLiquidityBody({routerWalletAddress:o,minLpOut:e.minLpOut}),u=BigInt(e.forwardGasAmount??this.gasConstants.provideLpJetton.forwardGasAmount),g=f({queryId:e.queryId??0,amount:e.sendAmount,destination:this.address,responseDestination:e.userWalletAddress,forwardTonAmount:u,forwardPayload:r}),y=BigInt(e.gasAmount??this.gasConstants.provideLpJetton.gasAmount);return{to:s,value:y,body:g}}async sendProvideLiquidityJetton(t,e,s){const o=await this.getProvideLiquidityJettonTxParams(t,s);return e.send(o)}async getProvideLiquidityTonTxParams(t,e){const s=await t.open(a.create(e.otherTokenAddress)).getWalletAddress(this.address),o=await this.createProvideLiquidityBody({routerWalletAddress:s,minLpOut:e.minLpOut}),r=BigInt(e.forwardGasAmount??this.gasConstants.provideLpTon.forwardGasAmount);return await t.open(e.proxyTon).getTonTransferTxParams({queryId:e.queryId??0,tonAmount:e.sendAmount,destinationAddress:this.address,refundAddress:e.userWalletAddress,forwardPayload:o,forwardTonAmount:r})}async sendProvideLiquidityTon(t,e,s){const o=await this.getProvideLiquidityTonTxParams(t,s);return e.send(o)}async getPoolAddress(t,e){return(await t.get("get_pool_address",[{type:"slice",cell:n.beginCell().storeAddress(d(e.token0)).endCell()},{type:"slice",cell:n.beginCell().storeAddress(d(e.token1)).endCell()}])).stack.readAddress()}async getPoolAddressByJettonMinters(t,e){const[s,o]=await Promise.all([t.open(a.create(e.token0)).getWalletAddress(this.address),t.open(a.create(e.token1)).getWalletAddress(this.address)]);return await this.getPoolAddress(t,{token0:s,token1:o})}async getPool(t,e){const s=await this.getPoolAddressByJettonMinters(t,{token0:e.token0,token1:e.token1});return V.create(s)}async getRouterData(t){const e=await t.get("get_router_data",[]);return{isLocked:e.stack.readBoolean(),adminAddress:e.stack.readAddress(),tempUpgrade:e.stack.readCell(),poolCode:e.stack.readCell(),jettonLpWalletCode:e.stack.readCell(),lpAccountCode:e.stack.readCell()}}};h.version=A.v1;h.address=n.address("EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt");h.gasConstants={swapJettonToJetton:{gasAmount:n.toNano("0.22"),forwardGasAmount:n.toNano("0.175")},swapJettonToTon:{gasAmount:n.toNano("0.17"),forwardGasAmount:n.toNano("0.125")},swapTonToJetton:{forwardGasAmount:n.toNano("0.185")},provideLpJetton:{gasAmount:n.toNano("0.3"),forwardGasAmount:n.toNano("0.24")},provideLpTon:{forwardGasAmount:n.toNano("0.26")}};let le=h;const ce={Router:le,Pool:V,LpAccount:E},b=class O extends w{constructor(t,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...O.gasConstants,...e}}async createRefundBody(t){return n.beginCell().storeUint(i.REFUND_ME,32).storeUint(t?.queryId??0,64).storeMaybeRef(t?.leftMaybePayload).storeMaybeRef(t?.rightMaybePayload).endCell()}async getRefundTxParams(t,e){const s=this.address,o=await this.createRefundBody({leftMaybePayload:e?.leftMaybePayload,rightMaybePayload:e?.rightMaybePayload,queryId:e?.queryId}),r=BigInt(e?.gasAmount??this.gasConstants.refund);return{to:s,value:r,body:o}}async sendRefund(t,e,s){const o=await this.getRefundTxParams(t,s);return e.send(o)}async createDirectAddLiquidityBody(t){return n.beginCell().storeUint(i.DIRECT_ADD_LIQUIDITY,32).storeUint(t?.queryId??0,64).storeCoins(BigInt(t.amount0)).storeCoins(BigInt(t.amount1)).storeCoins(BigInt(t.minimumLpToMint??1)).storeCoins(BigInt(t.customPayloadForwardGasAmount??0)).storeAddress(d(t.userWalletAddress)).storeMaybeRef(t.customPayload).storeRef(n.beginCell().storeAddress(d(t.refundAddress??t.userWalletAddress)).storeAddress(d(t.excessesAddress??t.refundAddress??t.userWalletAddress)).endCell()).endCell()}async getDirectAddLiquidityTxParams(t,e){const s=this.address,o=await this.createDirectAddLiquidityBody({amount0:e.amount0,amount1:e.amount1,minimumLpToMint:e.minimumLpToMint,userWalletAddress:e.userWalletAddress,refundAddress:e.refundAddress,excessesAddress:e.excessesAddress,customPayload:e.customPayload,customPayloadForwardGasAmount:e.customPayloadForwardGasAmount,queryId:e.queryId}),r=BigInt(e.gasAmount??this.gasConstants.directAddLp);return{to:s,value:r,body:o}}async sendDirectAddLiquidity(t,e,s){const o=await this.getDirectAddLiquidityTxParams(t,s);return e.send(o)}async createResetGasBody(t){return n.beginCell().storeUint(i.RESET_GAS,32).storeUint(t?.queryId??0,64).endCell()}async getResetGasTxParams(t,e){const s=this.address,o=await this.createResetGasBody({queryId:e?.queryId}),r=BigInt(e?.gasAmount??this.gasConstants.resetGas);return{to:s,value:r,body:o}}async sendResetGas(t,e,s){const o=await this.getResetGasTxParams(t,s);return e.send(o)}async getLpAccountData(t){const e=await t.get("get_lp_account_data",[]);return{userAddress:e.stack.readAddress(),poolAddress:e.stack.readAddress(),amount0:e.stack.readBigNumber(),amount1:e.stack.readBigNumber()}}};b.version=A.v2;b.gasConstants={refund:n.toNano("0.8"),directAddLp:n.toNano("0.3"),resetGas:n.toNano("0.02")};let U=b;const L=class M extends a{constructor(t,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...M.gasConstants,...e}}async createCollectFeesBody(t){return n.beginCell().storeUint(i.COLLECT_FEES,32).storeUint(t?.queryId??0,64).endCell()}async getCollectFeeTxParams(t,e){const s=this.address,o=await this.createCollectFeesBody({queryId:e?.queryId}),r=BigInt(e?.gasAmount??this.gasConstants.collectFees);return{to:s,value:r,body:o}}async sendCollectFees(t,e,s){const o=await this.getCollectFeeTxParams(t,s);return e.send(o)}async createBurnBody(t){return n.beginCell().storeUint(i.BURN,32).storeUint(t?.queryId??0,64).storeCoins(BigInt(t.amount)).storeAddress(null).storeMaybeRef(t.customPayload).endCell()}async getBurnTxParams(t,e){const[s,o]=await Promise.all([this.getWalletAddress(t,e.userWalletAddress),this.createBurnBody({amount:e.amount,customPayload:e.customPayload,queryId:e.queryId})]),r=BigInt(e.gasAmount??this.gasConstants.burn);return{to:s,value:r,body:o}}async sendBurn(t,e,s){const o=await this.getBurnTxParams(t,s);return e.send(o)}async getPoolType(t){return(await t.get("get_pool_type",[])).stack.readString()}async getLpAccountAddress(t,e){return(await t.get("get_lp_account_address",[{type:"slice",cell:n.beginCell().storeAddress(d(e.ownerAddress)).endCell()}])).stack.readAddress()}async getLpAccount(t,e){const s=await this.getLpAccountAddress(t,e);return U.create(s)}async getJettonWallet(t,e){const s=await this.getWalletAddress(t,e.ownerAddress);return _.create(s)}async getPoolData(t){return(await this.implGetPoolData(t)).commonPoolData}async implGetPoolData(t){const e=await t.get("get_pool_data",[]);return{commonPoolData:{isLocked:e.stack.readBoolean(),routerAddress:e.stack.readAddress(),totalSupplyLP:e.stack.readBigNumber(),reserve0:e.stack.readBigNumber(),reserve1:e.stack.readBigNumber(),token0WalletAddress:e.stack.readAddress(),token1WalletAddress:e.stack.readAddress(),lpFee:e.stack.readBigNumber(),protocolFee:e.stack.readBigNumber(),protocolFeeAddress:e.stack.readAddressOpt(),collectedToken0ProtocolFee:e.stack.readBigNumber(),collectedToken1ProtocolFee:e.stack.readBigNumber()},stack:e.stack}}};L.version=A.v2;L.gasConstants={collectFees:n.toNano("0.4"),burn:n.toNano("0.8")};let J=L;const R=class j extends w{constructor(t,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...j.gasConstants,...e}}async createWithdrawFeeBody(t){return n.beginCell().storeUint(i.WITHDRAW_FEE,32).storeUint(t?.queryId??0,64).endCell()}async getWithdrawFeeTxParams(t,e){const s=this.address,o=await this.createWithdrawFeeBody({queryId:e?.queryId}),r=BigInt(e?.gasAmount??this.gasConstants.withdrawFee);return{to:s,body:o,value:r}}async sendWithdrawFee(t,e,s){const o=await this.getWithdrawFeeTxParams(t,s);return e.send(o)}async getVaultData(t){const e=await t.get("get_vault_data",[]);return{ownerAddress:e.stack.readAddress(),tokenAddress:e.stack.readAddress(),routerAddress:e.stack.readAddress(),depositedAmount:e.stack.readBigNumber()}}};R.version=A.v2;R.gasConstants={withdrawFee:n.toNano("0.3")};let $=R;const W=class X extends w{constructor(t,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...X.gasConstants,...e}}async createSwapBody(t){if(t.referralValue&&(BigInt(t.referralValue)<0||BigInt(t.referralValue)>100))throw Error("'referralValue' should be in range (0, 100)");return n.beginCell().storeUint(i.SWAP,32).storeAddress(d(t.askJettonWalletAddress)).storeAddress(d(t.refundAddress)).storeAddress(d(t.excessesAddress??t.refundAddress)).storeRef(n.beginCell().storeCoins(BigInt(t.minAskAmount)).storeAddress(d(t.receiverAddress)).storeCoins(BigInt(t.customPayloadForwardGasAmount??0)).storeMaybeRef(t.customPayload).storeCoins(BigInt(t.refundForwardGasAmount??0)).storeMaybeRef(t.refundPayload).storeUint(BigInt(t.referralValue??10),16).storeAddress(t.referralAddress?d(t.referralAddress):null).endCell()).endCell()}async createCrossSwapBody(t){return n.beginCell().storeUint(i.CROSS_SWAP,32).storeAddress(d(t.askJettonWalletAddress)).storeAddress(d(t.refundAddress)).storeAddress(d(t.excessesAddress??t.refundAddress)).storeRef(n.beginCell().storeCoins(BigInt(t.minAskAmount)).storeAddress(d(t.receiverAddress)).storeCoins(BigInt(t.customPayloadForwardGasAmount??0)).storeMaybeRef(t.customPayload).storeCoins(BigInt(t.refundForwardGasAmount??0)).storeMaybeRef(t.refundPayload).storeUint(BigInt(t.referralValue??10),16).storeAddress(t.referralAddress?d(t.referralAddress):null).endCell()).endCell()}async getSwapJettonToJettonTxParams(t,e){const s=this.address,[o,r]=await Promise.all([t.open(a.create(e.offerJettonAddress)).getWalletAddress(e.userWalletAddress),t.open(a.create(e.askJettonAddress)).getWalletAddress(s)]),u=BigInt(e.forwardGasAmount??this.gasConstants.swapJettonToJetton.forwardGasAmount),g=await this.createSwapBody({askJettonWalletAddress:r,receiverAddress:e.userWalletAddress,minAskAmount:e.minAskAmount,refundAddress:e.refundAddress??e.userWalletAddress,excessesAddress:e.excessesAddress,referralAddress:e.referralAddress,referralValue:e.referralValue,customPayload:e.customPayload,customPayloadForwardGasAmount:e.customPayloadForwardGasAmount,refundPayload:e.refundPayload,refundForwardGasAmount:e.refundForwardGasAmount}),y=f({queryId:e.queryId??0,amount:e.offerAmount,destination:s,responseDestination:e.userWalletAddress,forwardPayload:g,forwardTonAmount:u}),B=BigInt(e.gasAmount??this.gasConstants.swapJettonToJetton.gasAmount);return{to:o,value:B,body:y}}async sendSwapJettonToJetton(t,e,s){const o=await this.getSwapJettonToJettonTxParams(t,s);return e.send(o)}async getSwapJettonToTonTxParams(t,e){return await this.getSwapJettonToJettonTxParams(t,{...e,askJettonAddress:e.proxyTon.address,gasAmount:e.gasAmount??this.gasConstants.swapJettonToTon.gasAmount,forwardGasAmount:e.forwardGasAmount??this.gasConstants.swapJettonToTon.forwardGasAmount})}async sendSwapJettonToTon(t,e,s){const o=await this.getSwapJettonToTonTxParams(t,s);return e.send(o)}async getSwapTonToJettonTxParams(t,e){const s=this.address,o=await t.open(a.create(e.askJettonAddress)).getWalletAddress(s),r=await this.createSwapBody({askJettonWalletAddress:o,receiverAddress:e.userWalletAddress,minAskAmount:e.minAskAmount,refundAddress:e.refundAddress??e.userWalletAddress,excessesAddress:e.excessesAddress,referralAddress:e.referralAddress,referralValue:e.referralValue,customPayload:e.customPayload,customPayloadForwardGasAmount:e.customPayloadForwardGasAmount,refundPayload:e.refundPayload,refundForwardGasAmount:e.refundForwardGasAmount}),u=BigInt(e.forwardGasAmount??this.gasConstants.swapTonToJetton.forwardGasAmount);return await t.open(e.proxyTon).getTonTransferTxParams({queryId:e.queryId??0,tonAmount:e.offerAmount,destinationAddress:s,refundAddress:e.userWalletAddress,forwardPayload:r,forwardTonAmount:u})}async sendSwapTonToJetton(t,e,s){const o=await this.getSwapTonToJettonTxParams(t,s);return e.send(o)}async createProvideLiquidityBody(t){return n.beginCell().storeUint(i.PROVIDE_LP,32).storeAddress(d(t.routerWalletAddress)).storeAddress(d(t.refundAddress)).storeAddress(d(t.excessesAddress??t.refundAddress)).storeRef(n.beginCell().storeCoins(BigInt(t.minLpOut)).storeAddress(d(t.receiverAddress)).storeUint(t.bothPositive?1:0,1).storeCoins(BigInt(t.customPayloadForwardGasAmount??0)).storeMaybeRef(t.customPayload).endCell()).endCell()}async createCrossProvideLiquidityBody(t){return n.beginCell().storeUint(i.CROSS_PROVIDE_LP,32).storeAddress(d(t.routerWalletAddress)).storeAddress(d(t.refundAddress)).storeAddress(d(t.excessesAddress??t.refundAddress)).storeRef(n.beginCell().storeCoins(BigInt(t.minLpOut)).storeAddress(d(t.receiverAddress)).storeUint(t.bothPositive?1:0,1).storeCoins(BigInt(t.customPayloadForwardGasAmount??0)).storeMaybeRef(t.customPayload).endCell()).endCell()}async getProvideLiquidityJettonTxParams(t,e){return this.implGetProvideLiquidityJettonTxParams(t,{...e,gasAmount:e.gasAmount??this.gasConstants.provideLpJetton.gasAmount,forwardGasAmount:e.forwardGasAmount??this.gasConstants.provideLpJetton.forwardGasAmount,bothPositive:!0})}async sendProvideLiquidityJetton(t,e,s){const o=await this.getProvideLiquidityJettonTxParams(t,s);return e.send(o)}async getSingleSideProvideLiquidityJettonTxParams(t,e){return this.implGetProvideLiquidityJettonTxParams(t,{...e,gasAmount:e.gasAmount??this.gasConstants.singleSideProvideLpJetton.gasAmount,forwardGasAmount:e.forwardGasAmount??this.gasConstants.singleSideProvideLpJetton.forwardGasAmount,bothPositive:!1})}async sendSingleSideProvideLiquidityJetton(t,e,s){const o=await this.getSingleSideProvideLiquidityJettonTxParams(t,s);return e.send(o)}async implGetProvideLiquidityJettonTxParams(t,e){const s=this.address,[o,r]=await Promise.all([t.open(a.create(e.sendTokenAddress)).getWalletAddress(e.userWalletAddress),t.open(a.create(e.otherTokenAddress)).getWalletAddress(s)]),u=await this.createProvideLiquidityBody({routerWalletAddress:r,receiverAddress:e.userWalletAddress,minLpOut:e.minLpOut,refundAddress:e.refundAddress??e.userWalletAddress,excessesAddress:e.excessesAddress,customPayload:e.customPayload,customPayloadForwardGasAmount:e.customPayloadForwardGasAmount,bothPositive:e.bothPositive}),g=BigInt(e.forwardGasAmount),y=f({queryId:e.queryId??0,amount:e.sendAmount,destination:s,responseDestination:e.userWalletAddress,forwardTonAmount:g,forwardPayload:u}),B=BigInt(e.gasAmount);return{to:o,value:B,body:y}}async getProvideLiquidityTonTxParams(t,e){return this.implGetProvideLiquidityTonTxParams(t,{...e,forwardGasAmount:e.forwardGasAmount??this.gasConstants.provideLpTon.forwardGasAmount,bothPositive:!0})}async sendProvideLiquidityTon(t,e,s){const o=await this.getProvideLiquidityTonTxParams(t,s);return e.send(o)}async getSingleSideProvideLiquidityTonTxParams(t,e){return this.implGetProvideLiquidityTonTxParams(t,{...e,forwardGasAmount:e.forwardGasAmount??this.gasConstants.singleSideProvideLpTon.forwardGasAmount,bothPositive:!1})}async sendSingleSideProvideLiquidityTon(t,e,s){const o=await this.getSingleSideProvideLiquidityTonTxParams(t,s);return e.send(o)}async implGetProvideLiquidityTonTxParams(t,e){const s=this.address,o=await t.open(a.create(e.otherTokenAddress)).getWalletAddress(s),r=await this.createProvideLiquidityBody({routerWalletAddress:o,receiverAddress:e.userWalletAddress,minLpOut:e.minLpOut,refundAddress:e.refundAddress??e.userWalletAddress,excessesAddress:e.excessesAddress,customPayload:e.customPayload,customPayloadForwardGasAmount:e.customPayloadForwardGasAmount,bothPositive:e.bothPositive}),u=BigInt(e.forwardGasAmount);return await t.open(e.proxyTon).getTonTransferTxParams({queryId:e.queryId??0,tonAmount:e.sendAmount,destinationAddress:s,refundAddress:e.userWalletAddress,forwardPayload:r,forwardTonAmount:u})}async getPoolAddress(t,e){return(await t.get("get_pool_address",[{type:"slice",cell:n.beginCell().storeAddress(d(e.token0)).endCell()},{type:"slice",cell:n.beginCell().storeAddress(d(e.token1)).endCell()}])).stack.readAddress()}async getPoolAddressByJettonMinters(t,e){const[s,o]=await Promise.all([t.open(a.create(e.token0)).getWalletAddress(this.address),t.open(a.create(e.token1)).getWalletAddress(this.address)]);return await this.getPoolAddress(t,{token0:s,token1:o})}async getPool(t,e){const s=await this.getPoolAddressByJettonMinters(t,e);return J.create(s)}async getVaultAddress(t,e){return(await t.get("get_vault_address",[{type:"slice",cell:n.beginCell().storeAddress(d(e.user)).endCell()},{type:"slice",cell:n.beginCell().storeAddress(d(e.tokenWallet)).endCell()}])).stack.readAddress()}async getVault(t,e){const s=t.open(a.create(e.tokenMinter)),o=await this.getVaultAddress(t,{user:e.user,tokenWallet:await s.getWalletAddress(this.address)});return $.create(o)}async getRouterVersion(t){const e=await t.get("get_router_version",[]);return{major:e.stack.readNumber(),minor:e.stack.readNumber(),development:e.stack.readString()}}async getRouterData(t){const e=await t.get("get_router_data",[]);return{routerId:e.stack.readNumber(),dexType:e.stack.readString(),isLocked:e.stack.readBoolean(),adminAddress:e.stack.readAddress(),tempUpgrade:e.stack.readCell(),poolCode:e.stack.readCell(),jettonLpWalletCode:e.stack.readCell(),lpAccountCode:e.stack.readCell(),vaultCode:e.stack.readCell()}}};W.version=A.v2;W.gasConstants={swapJettonToJetton:{gasAmount:n.toNano("0.3"),forwardGasAmount:n.toNano("0.24")},swapJettonToTon:{gasAmount:n.toNano("0.3"),forwardGasAmount:n.toNano("0.24")},swapTonToJetton:{forwardGasAmount:n.toNano("0.3")},provideLpJetton:{gasAmount:n.toNano("0.3"),forwardGasAmount:n.toNano("0.235")},provideLpTon:{forwardGasAmount:n.toNano("0.3")},singleSideProvideLpJetton:{gasAmount:n.toNano("1"),forwardGasAmount:n.toNano("0.8")},singleSideProvideLpTon:{forwardGasAmount:n.toNano("0.8")}};let Q=W;class q extends J{async getPoolData(t){return{...(await this.implGetPoolData(t)).commonPoolData}}}q.dexType=S.CPI;class p extends Q{async getPool(t,e){const s=await this.getPoolAddressByJettonMinters(t,e);return q.create(s)}}p.dexType=S.CPI;class Y extends Q{}Y.CPI=p;class K extends J{}K.CPI=q;const Ae={Router:Y,Pool:K,LpAccount:U,Vault:$},c={[A.v1]:ce,[A.v2]:Ae},G=class Z extends a{constructor(t=Z.address,e){super(t,e)}async getTonTransferTxParams(t,e){const s=await this.getWalletAddress(t,e.destinationAddress),o=f({queryId:e.queryId??0,amount:e.tonAmount,destination:e.destinationAddress,forwardTonAmount:BigInt(e.forwardTonAmount??0),forwardPayload:e.forwardPayload}),r=BigInt(e.tonAmount)+BigInt(e.forwardTonAmount??0);return{to:s,value:r,body:o}}async sendTonTransfer(t,e,s){const o=await this.getTonTransferTxParams(t,s);return e.send(o)}};G.version=v.v1;G.address=n.address("EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez");let z=G;const N=class H extends z{constructor(t,{gasConstants:e,...s}={}){super(t,s),this.gasConstants={...H.gasConstants,...e}}async createTonTransferBody(t){const e=n.beginCell();return e.storeUint(oe.TON_TRANSFER,32),e.storeUint(t.queryId??0,64),e.storeCoins(BigInt(t.tonAmount)),e.storeAddress(d(t.refundAddress)),t.forwardPayload&&(e.storeBit(!0),e.storeRef(t.forwardPayload)),e.endCell()}async getTonTransferTxParams(t,e){const s=await this.getWalletAddress(t,e.destinationAddress),o=await this.createTonTransferBody({tonAmount:e.tonAmount,refundAddress:e.refundAddress,forwardPayload:e.forwardPayload,queryId:e.queryId}),r=BigInt(e.tonAmount)+BigInt(e.forwardTonAmount??0)+BigInt(this.gasConstants.tonTransfer);return{to:s,value:r,body:o}}async sendTonTransfer(t,e,s){const o=await this.getTonTransferTxParams(t,s);return e.send(o)}};N.version=v.v2;N.gasConstants={tonTransfer:n.toNano("0.01")};let ge=N;const ye={[v.v1]:z,[v.v2]:ge};class m extends Error{constructor(t,e){const s="UnknownRouterError",r=[`Unknown router with address ${t.debug}`,e];super(...r),this.address=t,this.name=s,Object.setPrototypeOf(this,new.target.prototype)}}class he extends te{getRouterByAddress;PTON_CONTRACT_ADDRESS;constructor(t){super(t),this.getRouterByAddress=t.getRouterByAddress,this.PTON_CONTRACT_ADDRESS=t.PTON_CONTRACT_ADDRESS}buildRouterContract(t){const e=this.getRouterByAddress(t);if(!e)return new m(t);switch(e.version){case c.v1.Router.version:{const s=ee.toNano(.02);return new c.v1.Router(e.address.base64,{gasConstants:{swapJettonToJetton:{...c.v1.Router.gasConstants.swapJettonToJetton,gasAmount:c.v1.Router.gasConstants.swapJettonToJetton.gasAmount+s},swapJettonToTon:{...c.v1.Router.gasConstants.swapJettonToTon,gasAmount:c.v1.Router.gasConstants.swapJettonToTon.gasAmount+s},provideLpJetton:{...c.v1.Router.gasConstants.provideLpJetton,gasAmount:c.v1.Router.gasConstants.provideLpJetton.gasAmount+s}}})}default:throw new Error(`Unknown router version: ${e.version}`)}}buildPoolContract(t,e){const s=this.getRouterByAddress(t);if(!s)return new m(t);switch(s.version){case c.v1.Pool.version:return new c.v1.Pool(e.base64);default:throw new Error(`Unknown router version: ${s.version}`)}}buildLpAccountContract(t,e){const s=this.getRouterByAddress(t);if(!s)return new m(t);switch(s.version){case c.v1.LpAccount.version:return new c.v1.LpAccount(e.base64);default:throw new Error(`Unknown router version: ${s.version}`)}}buildProxyTonContract(){return new ye.v1}}const Be={...se,getRouterByAddress:C.getRouterByAddress.bind(C),getDefaultRouter:C.getDefaultRouter.bind(C),PTON_CONTRACT_ADDRESS:ne.PTON_CONTRACT_ADDRESS},me=({value:l,options:t,...e})=>{const{formatter:s}=re();return T.jsx("span",{...e,children:s.address(l,t)})},P={OPEN:"open",CLOSED:"closed"},xe=({isOpen:l,onOpen:t,onClose:e,summary:s,children:o,...r})=>T.jsx(de,{...r,type:"single",collapsible:!0,defaultValue:l===void 0?P.CLOSED:void 0,value:l!==void 0?l?P.OPEN:P.CLOSED:void 0,onValueChange:u=>u===P.OPEN?t?.():e?.(),children:T.jsxs(ae,{value:P.OPEN,children:[T.jsx(ie,{className:"w-full",children:s}),T.jsx(ue,{children:o})]})});export{me as A,xe as D,_ as J,he as R,Be as r};
