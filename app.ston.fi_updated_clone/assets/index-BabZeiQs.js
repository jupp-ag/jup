import{al as O,am as T,a2 as b,Z as B,a3 as h,a7 as p,H as C,G as D,M as F,W as x,A as R,I as k}from"./index-rYEy9Y7-.js";import{A as L,M as S,g as N}from"./Skeleton-DP44cgo5.js";import{R as $}from"./index-CxvHtgaJ.js";import{z as i,E,m as q,k as z,o as Q,A as V,j as w}from"./vendors-Dtot3KuJ.js";import{P as H}from"./PoolBalance-BIui72E6.js";const v=i.object({address:i.string(),router_address:i.string(),reserve0:i.string(),reserve1:i.string(),token0_address:i.string(),token1_address:i.string(),lp_total_supply:i.string(),lp_total_supply_usd:i.string().nullish(),lp_fee:i.string(),protocol_fee:i.string(),ref_fee:i.string(),protocol_fee_address:i.string(),collected_token0_protocol_fee:i.string(),collected_token1_protocol_fee:i.string(),lp_wallet_address:i.string().nullish(),lp_account_address:i.string().nullish(),lp_balance:i.string().nullish(),lp_value_usd:i.string().nullish(),lp_price_usd:i.string().nullish(),token0_balance:i.string().nullish(),token1_balance:i.string().nullish(),apy_1d:i.string().nullish(),apy_7d:i.string().nullish(),apy_30d:i.string().nullish(),tvl:i.string().nullish(),volume_24h_usd:i.string().nullish(),deprecated:i.boolean()});class I extends Error{constructor(e){const s="PoolFetchMetadataError",r=["Could not fetch pool metadata",e];super(...r),this.name=s,Object.setPrototypeOf(this,new.target.prototype)}}let M=class{constructor(e){this.dependencies=e,this.cache=new O({StorageService:this.dependencies.StorageService,STORAGE_KEY:this.dependencies.CACHE_STORAGE_KEY,DEFAULT_VALUE:new Map,SERIALIZER:s=>JSON.stringify(Array.from(s.entries())),DESERIALIZER:s=>T.stringToJSON().transform(t=>i.array(i.tuple([i.string(),v])).transform(r=>new Map(r)).parse(t)).parse(s)})}cache;async fetchPoolsMetadata(e){const{logger:s,StonAPI:t}=this.dependencies,{walletAddress:r,loadNonLiquid:n,loadDeprecated:a,loadCommunity:o}=e,c=s.child(`fetchPoolsMetadata for ${r?.debug??"undefined"} wallet`);try{c.log("fetching pools");const l=r?await t.getPoolsBalances({wallet_address:r.base64,load_lp_accounts:!1,optimize_load:!n,load_community:o}):await t.getPoolsList({optimize_load:!n,load_community:o});if(l instanceof Error)throw l;const d=l.pools.reduce((f,_)=>{const u=v.safeParse(_);return u.success?f.push(u.data):c.warn("fail to parse pool metadata",_,u.error),f},[]);return c.log("fetched",d),this.updatePoolsMetadataInCache(d),d}catch(l){const d=new I({cause:l});return c.error("failed to fetch",d),d}}async fetchPoolsBalances({walletAddress:e}){const{logger:s,StonAPI:t}=this.dependencies,r=s.child("fetchPoolMetadata");try{r.log(`fetching pools balances for ${e.debug}`);const n=await t.getPoolsBalancesMap({wallet_address:e.base64});if(n instanceof Error)throw n;const a=n.balance_map;return r.log("fetched",a),a}catch(n){return r.error("failed to fetch",{cause:n}),{}}}async fetchPoolMetadata(e,s){const{logger:t,StonAPI:r}=this.dependencies,n=t.child("fetchPoolMetadata");try{n.log(`fetching pool for ${s.debug} and ${e?.debug??"undefined"} wallet`);const a=e?await r.getPoolBalance({wallet_address:e.base64,pool_address:s.base64}):await r.getPoolInfo({pool_address:s.base64});if(a instanceof Error)throw a;const o=v.parse(a);return n.log("fetched",o),this.updatePoolsMetadataInCache([...this.getCachedPoolsMetadata(),o]),o}catch(a){const o=new I({cause:a});return n.error("failed to fetch",o),o}}async fetchIsPoolExist({routerAddress:e,tokenA:s,tokenB:t}){const{logger:r,StonAPI:n}=this.dependencies,a=r.child("fetchIsPoolExist");try{const o=await n.isPoolExist({router_address:e.base64,token_a:s.contractAddress.base64,token_b:t.contractAddress.base64});if(o instanceof Error)throw o;return o.pool_exist}catch(o){a.error("failed to fetch",{cause:o});return}}buildPoolLpTokenEntity({address:e,tokenA:s,tokenB:t,lpTokenPriceUSD:r}){const n=[s,t].sort(b.sort).map(a=>a.symbol).join("/");return new b({type:B.JETTON,name:`${n} LP`,symbol:n,contractAddress:e,decimals:9,priority:0,isBlacklisted:s.isBlacklisted||t.isBlacklisted,isCommunity:s.isCommunity||t.isCommunity,isDeprecated:s.isDeprecated||t.isDeprecated,imageURL:null,isVerified:s.isVerified&&t.isVerified,isImported:!1,isFavorite:!1,isTaxable:!1,priceUSD:r})}buildPoolEntity(e){const{dependencies:{AssetsStore:s,logger:t}}=this;try{const r=new h(e.token0_address),n=s.getAssetByAddress(r);if(!n)throw new Error(`Asset with address "${r.debug}" not found`);const a=new h(e.token1_address),o=s.getAssetByAddress(a);if(!o)throw new Error(`Asset with address "${a.debug}" not found`);const c=this.dependencies.RoutersStore.getRouterByAddress(new h(e.router_address));if(!c)throw new Error(`Router with address "${e.router_address}" not found`);const l=P=>{if(typeof P!="string"&&typeof P!="number")return;const m=parseFloat(P.toString());return isFinite(m)&&!isNaN(m)?m:void 0},d=new h(e.address),f=l(e.lp_price_usd),_=this.buildPoolLpTokenEntity({address:d,tokenA:n,tokenB:o,lpTokenPriceUSD:f}),u=P=>parseFloat(P)/100/100;return new H({address:d,pooledAmountUSD:l(e.lp_value_usd),router:c,tokenA:n,tokenAAmount:new p({...n,amount:e.reserve0,walletAddress:null}),accountTokenA:new p({...n,amount:e.token0_balance??0,walletAddress:e.lp_account_address?new h(e.lp_account_address):null}),tokenB:o,tokenBAmount:new p({...o,amount:e.reserve1,walletAddress:null}),accountTokenB:new p({...o,amount:e.token1_balance??0,walletAddress:e.lp_account_address?new h(e.lp_account_address):null}),lpToken:_,lpTokenAmount:new p({..._,amount:e.lp_total_supply,walletAddress:null}),lpTokenPriceUSD:f,lpTokensOwned:new p({..._,amount:e.lp_balance??0,walletAddress:e.lp_wallet_address?new h(e.lp_wallet_address):null}),lpFeePercent:u(e.lp_fee),protocolFeePercent:u(e.protocol_fee),refFeePercent:u(e.ref_fee),apy1d:l(e.apy_1d),apy7d:l(e.apy_7d),apy30d:l(e.apy_30d),tvl:l(e.tvl),volume24h:l(e.volume_24h_usd)})}catch(r){return t.child("buildPoolEntity").warn("failed to create entity from metadata",e,r),null}}sanitizePoolMetadata(e){return{...e,lp_wallet_address:void 0,lp_account_address:void 0,token0_balance:void 0,token1_balance:void 0,lp_value_usd:void 0,lp_balance:void 0}}getCachedPoolsMetadata(){return Array.from(this.cache.data.values())}sanitizeCachedPoolsMetadata(){return this.updatePoolsMetadataInCache(this.getCachedPoolsMetadata().map(this.sanitizePoolMetadata)),this.getCachedPoolsMetadata()}updatePoolsMetadataInCache(e){const s=new Map(e.filter(t=>typeof t.tvl=="string"&&+t.tvl>1e3||t.lp_balance||t.token0_balance||t.token1_balance).map(t=>[t.address,t]));this.cache.updateCache(s)}};const j=new M({logger:C.child("services","PoolsService"),StonAPI:D,RoutersStore:$,AssetsStore:L,StorageService:F,CACHE_STORAGE_KEY:"pools"});var K=Object.defineProperty,U=Object.getOwnPropertyDescriptor,A=(g,e,s,t)=>{for(var r=U(e,s),n=g.length-1,a;n>=0;n--)(a=g[n])&&(r=a(e,s,r)||r);return r&&K(e,s,r),r};let y=class{constructor(e){this.dependencies=e,this._logger=e.logger;const{AppSettingsStore:s,WalletStore:t,AssetsStore:r,PoolsService:n}=e;this._poolsQuery=new S(()=>({queryKey:["PoolsStore._poolsQuery",`wallet-${t.wallet?.key}`],enabled:t.wallet!==void 0&&r.isInitialized,initialData:n.getCachedPoolsMetadata().map(n.sanitizePoolMetadata),queryFn:async()=>{const a=await n.fetchPoolsMetadata({walletAddress:t.wallet?.address,loadNonLiquid:s.showNonLiquidAssets,loadCommunity:s.showCommunityAssets,loadDeprecated:s.showDeprecatedAssets});if(a instanceof Error)throw a;return a},select:a=>{E(()=>{const{removed:o,updated:c,added:l}=N(this._poolsMetadataMap,new Map(a.map(d=>[d.address,d])));[...l,...c].forEach(d=>this._setPoolData(d)),o.forEach(d=>this._deletePoolData(d))})},refetchOnMount:!0,refetchOnWindowFocus:!1,refetchInterval:e.POOLS_REFETCH_INTERVAL_MS})),this._poolsBalancesQuery=new S(()=>({queryKey:["PoolsStore._poolsBalancesQuery",`wallet-${t.wallet?.key}`],enabled:!!t.wallet&&!!this._poolsQuery.state.isFetched,queryFn:async()=>{const a=t.wallet?.address;if(!a)return{};const o=await n.fetchPoolsBalances({walletAddress:a});if(o instanceof Error)throw o;return o},select:a=>{E(()=>{Object.entries(a).forEach(([o,c])=>{const l=this._poolsMetadataMap.get(o);l!==void 0&&l.lp_balance!==c&&this._patchPoolData({address:o,lp_balance:c})})})},refetchInterval:e.POOLS_BALANCES_REFETCH_INTERVAL_MS})),q(this,void 0,{name:"PoolsStore"}),z(()=>[e.AppSettingsStore.showCommunityAssets,e.AppSettingsStore.showDeprecatedAssets,e.AppSettingsStore.showNonLiquidAssets],()=>this._poolsQuery.refetch(),{name:"On AppSettingsStore assets flags change"})}_logger;_poolsQuery;_poolsBalancesQuery;_poolsMetadataMap=Q.map([],{deep:!1});_assetIndex=new Map;_assetPairIndex=new Map;get allPools(){const e=[];for(const s of this._poolsMetadataMap.values()){const t=this.dependencies.PoolsService.buildPoolEntity(s);t&&e.push(t)}return e.length!==0?e:void 0}get pools(){return this.allPools?this.allPools.filter(e=>this._filterPools(e)):this.allPools}get isInitialized(){return this.pools!==void 0}get isFetched(){return this._poolsQuery.state.isFetched}getPoolByAddress=e=>this._getPoolByAddress(e.key);_getPoolByAddress(e){const s=this._poolsMetadataMap.get(e);return s?this.dependencies.PoolsService.buildPoolEntity(s):null}getPoolByAssets=(e,s)=>{const t=[...this._getAssetPairIndex(e.contractAddress.key,s.contractAddress.key)];return t.length>0?this._getPoolByAddress(t[0]):null};getPoolsByAsset=e=>[...this._getAssetIndex(e.contractAddress.key)].map(s=>this._getPoolByAddress(s)).filter(Boolean);fetchPools=async()=>(await this._poolsQuery.refetch(),this.pools);fetchPool=async e=>{const{WalletStore:s,AssetsStore:t,PoolsService:r}=this.dependencies;await V(()=>t.isInitialized);const n=new S(()=>({queryKey:["PoolsStore._poolQuery",`wallet-${s.wallet?.key}`,`pool-${e.key}`],queryFn:async()=>{const o=await r.fetchPoolMetadata(s.wallet?.address,e);if(o instanceof Error)throw o;return o},refetchOnMount:!1,select:o=>{E(()=>{this._setPoolData(o)})}}));return await n.refetch().finally(()=>n.dispose()),this.getPoolByAddress(e)};_filterPools(e){const{dependencies:{AppSettingsStore:{showDeprecatedAssets:s,showCommunityAssets:t}}}=this;return e.isBlacklisted||!e.isInitialized?e.hasProvidedLiquidity:e.isDeprecated?e.hasProvidedLiquidity||s:e.isCommunity?e.hasProvidedLiquidity||t:!0}_setPoolData=e=>{this._poolsMetadataMap.set(e.address,e),this._getAssetIndex(e.token0_address).add(e.address),this._getAssetIndex(e.token1_address).add(e.address),this._getAssetPairIndex(e.token0_address,e.token1_address).add(e.address),this._getAssetPairIndex(e.token1_address,e.token0_address).add(e.address)};_patchPoolData=e=>{const s=this._poolsMetadataMap.get(e.address);s&&this._setPoolData({...s,...e})};_deletePoolData=e=>{this._poolsMetadataMap.delete(e.address),this._getAssetIndex(e.token0_address).delete(e.address),this._getAssetIndex(e.token1_address).delete(e.address),this._getAssetPairIndex(e.token0_address,e.token1_address).delete(e.address),this._getAssetPairIndex(e.token1_address,e.token0_address).delete(e.address)};_getAssetIndex(e){let s=this._assetIndex.get(e);return s===void 0&&(s=new Set,this._assetIndex.set(e,s)),s}_getAssetPairIndex(e,s){const t=`${e},${s}`;let r=this._assetPairIndex.get(t);return r===void 0&&(r=new Set,this._assetPairIndex.set(t,r)),r}};A([w],y.prototype,"allPools");A([w],y.prototype,"pools");A([w],y.prototype,"isInitialized");A([w],y.prototype,"isFetched");const te=new y({logger:C.child("stores","PoolsStore"),PoolsService:j,AssetsStore:L,WalletStore:x,AppSettingsStore:R,POOLS_REFETCH_INTERVAL_MS:k.APP_POOLS_REFETCH_INTERVAL_MS,POOLS_BALANCES_REFETCH_INTERVAL_MS:k.APP_POOLS_BALANCES_REFETCH_INTERVAL_MS});export{te as P,j as a};
